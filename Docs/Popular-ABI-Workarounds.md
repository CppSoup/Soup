# Popular ABI Workarounds
A popular way to share native code was to pre-build the binaries and distribute a single dynamic library along with a set of public header files. However this presents a host of ABI compatibility issues. A way to bypass these issues is to only expose a C style public binary layer that takes advantage of the fact that C **does** have a standardized binary layer. This requires that all C++ implementation code be wrapped in a public C layer, and if a client wishes to use modern C++ practices, the C layer can then be wrapped in yet another C++ layer that is compiled within the consumer project itself. 

A second pattern that allows for the distribution of pre-built native binaries, is to expose a single C style entry point, and from then on, use only interfaces when communicating across the boundary (Note: beware of exceptions or standard library objects passing over the boundary!) While it is not technically a requirement that C++ interface definitions have a standard ABI, Microsoft has effectively standardized this approach through the sheer number of projects that utilize it through [COM](https://en.wikipedia.org/wiki/Component_Object_Model). Both of these approaches will produce fully compatible binaries that can be distributed to others. However, the overhead of either approach is often not worthwhile unless your shared component is very large.

A third pattern to binary compatibility issues is to have no binaries at all. Some communities that maintain smaller projects, have taken to embedding both the definition and implementation into header only libraries. When including the headers in your project, you are effectively building the project for them. Due to the constraint that you must now place all of your source in your public headers, these headers can grow unwieldy and will be unmanageable for large projects. Large headers can also have a negative impact on build performance as they are re-parsed multiple times in every translation unit that consumes them.

A relatively modern approach to consuming external dependencies is through package managers. A package manager distributes the raw source, along with the build definition required to integrate with your project. As long as the two systems are compatible, it will automatically inject the child dependency into your build, or download the pre-built binaries that were carefully cataloged to have the same compiler, architecture, and configurations. Overall this approach works well. It's drawback though, is that it requires that the package manager either be able to generate the required build definitions used by consumers or be directly integrated within a build system. This requires custom integration logic between a package manager and the possibly build systems it supports.