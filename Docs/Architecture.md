
# Architecture
This build system, called **Soup**, will utilize a declarative **Recipe** file as an easy to understand definition for an individual Package. This file will be the primary way to tell Soup about your project. The core command line application will be used to invoke the build and provide extra configuration parameters. Internally, Soup uses a **Task** execution engine to run build Tasks in their requested order and exposes a registration mechanism to allow for C++ "Extension" Dynamic Libraries to run arbitrary code during the build. The Tasks are expected to generate a [Directed Acyclic Graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) of build **Operations** that make up the actual build. Theses Operations will be executed to produce the final build result. The primary design consists of four key components: the command line application, the build definition, the build engine, and the package manager.

## Application
The [Command Line Interface (CLI)](CLI.md) is the first thing a user will see when they interact with the Soup build system. The CLI is primarily there to take user input through a set of parameters and flags to pass temporary configuration values into the build execution. While important, it is fairly straightforward to design and will be left open to evolve through use.

## Definition
The build definition, which will be implemented through a declarative Recipe configuration file is how the user will configure their project. The Recipe file will utilize the [toml](https://github.com/toml-lang/toml) language as a clean, human readable, configuration definition that supports a core set of data types. The file can be thought of as a simple property bag for getting shared parameters passed into the build system for an individual package. There are a few "known" property values that will be used within the build engine itself; however, the entire contents will be provided as initial input to the build engine.

## Engine
The build Engine is responsible for recursively building all transitive dependencies, facilitating the registration and execution of build Tasks, and executing all requirement build Operations. All build logic will be contained in Tasks and all build execution will be performed in Operations. Having this extra layer of separation between the build evaluation and the build execution allows for build Extensions to get fast incremental build support for "free" and will allow for future performance improvements without introducing breaking changes into the Extension Framework. 

This work can be broken down into five phases:
1. **Parse Recipe** - The Recipe toml file is read from disk and parsed into a property bag.
2. **Build Dependencies** - The Engine will use the known property lists "Dependencies" and "DevDependencies" to recursively build all transitive runtime and development dependencies starting at phase one. The Engine will maintain a communication channel between parent and children project builds, to allow for passing configuration parameters down and output state back up using a special property bag container.
3. **Build Extensions** - The Engine will then discover and invoke the predefined C method that is exported from all registered Extension DLLs. A single predefined Extension DLL, that is distributed with the CLI executable, contains the Tasks that execute the default build logic that will allow for building projects for a majority of scenarios.
4. **Run Tasks** - A Build Task will consist of a unique name, lists of other Tasks that must be run before and after, and a single execute entry point. The build Tasks will communicate with the build Engine itself through a strict interface layer to maintain a compatible ABI that will allow the CLI executable to work with the source compiled development dependencies from a different compiler. The build Engine will invoke all registered build Tasks in their requested order as defined by the run Before/After lists. The Tasks can influence each other by reading and writing properties to and from the active state (a shared property bag). A build Task should not actually perform any build commands itself (compile/link/copy/etc.), it will instead generate build Operations which are self contained executable definitions with input/output files.
5. **Run Operations** - The final stage of the build is to execute the build Operations that were generated from the build Tasks. These commands contain the executable and parameters to pass in, as well as, the input and output files that will be used to perform incremental builds. The initial implementation will be a very simple time-stamp based incremental build that relies on the Windows Detour Project to intercept Win32 API Calls to track access to the filesystem. There is still an open question on how this will be implemented on the Linux implementation.

## Package Manager
You may have noticed that nothing about the build explicitly deals with the integration of a public feed of packages. Because each individual projects build is isolated and self contained, a dependency reference can easily be migrated from a direct directory reference, for local projects, to a name@version pair that will be resolved to a published snapshot of a public project. The CLI application will consume a rest API from a hosted web service that allows for users to install other projects and publish the code they would like to share with ease. The build Engine will then have a small amount of integration logic that knows where to look when resolving dependencies that reference a public package that will be installed to a known location. It should be noted that these public dependency references can be for both runtime and developer dependencies. This will allow for shared packages to contain custom build logic and for the creation of shared build Extensions to augment the built in build Tasks.